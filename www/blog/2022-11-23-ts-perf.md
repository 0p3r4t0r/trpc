---
slug: ts-perf
# TODO: better title (pls help me)
title: How can you improve the performance of your TypeScript?
author: Sachin Raja
author_title: tRPC Core Team Member
author_url: https://twitter.com/s4chinraja
author_image_url: https://avatars1.githubusercontent.com/u/58836760?s=460&v=4
---

As library authors, we seek to provide the best possible developer experience (DX) for our users. Reducing time-to-error, narrowing down exactly what can be passed and accessed where, and providing intuitive APIs at every step all contribute to this. TypeScript has become a major tool in enabling us to ship such DX.

However, as TypeScript usage becomes more widespread and libraries like tRPC and, more recently, [TanStack Router](https://tanstack.com/router/v1) are built entirely around it, we must understand the implications on type-checking and language server performance.

## Where to start?

First, consider if you need to optimize your types. App developers should not have to worry about types on that level, but library maintainers play a crucial role in ensuring their editing experience remains smooth.

Regardless of whether your library is slow _now_, it's important to keep an eye on performance as your library changes. You must test your library's performance to the max **on each commit**.

For tRPC, we ensure this by [generating](https://github.com/trpc/trpc/blob/9fc2d06a8924da73e10b9d4497f3a1f53de706ed/scripts/generateBigBoi.ts) and [testing](https://github.com/trpc/trpc/blob/9fc2d06a8924da73e10b9d4497f3a1f53de706ed/packages/tests/server/react/bigBoi.test.tsx) a router with 3,500 procedures and 1,000 routers. We test all aspects of the library: server, vanilla client, and the React client because they all have different code (type?) paths and have individually regressed in the past.

All of these are indicators that you need to optimize your types:

- Your library is slow to type-check (using `tsc`)
- Your library has a huge initial load time
- The TypeScript language server takes a long time to respond to changes e.g. when you're making edits in a file. This is the most important one as it has the greatest effect on DX. You **never** want to your users to wait for the language server to update after a change.

## How to optimize?

First, cut down as much as possible. Do you need the best possible TypeScript types everywhere? Is there anywhere you can cut down on the complexity of your types? Not every type needs to be perfect. The more complex your types are, the more work TypeScript has to do.

Example:

Do you really need this?

```ts
export const colorHexMap = {
  red: '#ff0000',
  green: '#00ff00',
  blue: '#0000ff',
  // ...1000 more colors
} as const;

const blueHex = colorHexMap.blue;
```

Maybe this will work just as well?

```ts
export const colorHexMap: Record<string, string> = {
  red: '#ff0000',
  green: '#00ff00',
  blue: '#0000ff',
  // ...1000 more colors
};

const blueHex = colorHexMap.blue;
```

The second example is much simpler and faster to type-check.

If you absolutely need your complex types, more work is required.

## A real-world example from tRPC

> PR in question: https://github.com/trpc/trpc/pull/2716

> Warning: The next sections require some knowledge of tRPC APIs and terminology.

TypeScript has a built-in [tracing tool](https://github.com/microsoft/TypeScript/wiki/Performance-Tracing) that can help you find the bottleneck in your types. It's not perfect, but it's the best tool available.

It's ideal to test your library on an example app. For tRPC, I created a basic [T3 app](https://create.t3.gg/) which resembles what users work with in a real-world app.

Here's the steps I followed to trace tRPC:

1. [Locally link library](https://docs.npmjs.com/cli/commands/npm-link) to the example app

2. Run this command in the example app:

```sh
tsc --generateTrace ./trace --incremental false
```

3. Open `trace/trace.json` in a trace analysis app (I use [Perfetto](https://ui.perfetto.dev/) but you can also use chrome://tracing).

This is where it gets interesting. I looked for for long bars that indicate a source file took a long time to type-check. Here's what it looked like:
![trace bar showing that src/pages/index.ts took 332ms to type-check](https://user-images.githubusercontent.com/58836760/190300723-5366674f-2fe0-48e9-8a00-7a8bc85b5c91.png)

This tells me that `src/pages/index.ts` is the bottleneck. Under the `Duration` field, you'll see that it took 332ms. That is an enormous amount of time to spend type-checking! That `checkVariableDeclaration` bar tells us it spent most of that time on one variable, our React Query `utiils = trpc.useContext()`.

But how could this be? We're just using a simple hook! Let's look at the code:

```tsx
import type { AppRouter } from '~/server/trpc';

const trpc = createTRPCReact<AppRouter>();
const Home: NextPage = () => {
  const { data } = trpc.r0.greeting.useQuery({ who: 'from tRPC' });

  const utils = trpc.useContext();

  utils.r49.greeting.invalidate();
  utils.r44.greeting3.setData('hello from tRPC');
};

export default Home;
```

> Note: The router and procedure paths look like that because they were generated for this example. Remember what I said about pushing your library to the max?

Ok, not much to see here. It's just a single `useContext` and a query invalidation. Nothing that _should be_ TypeScript heavy. We'll have to dive in further. Let's look at the types behind this:

```ts
type DecorateProcedure<
  TRouter extends AnyRouter,
  TProcedure extends Procedure<any>,
  TProcedure extends AnyQueryProcedure,
> = {
  /**
   * @link https://react-query.tanstack.com/guides/query-invalidation
   */
  invalidate(
    input?: inferProcedureInput<TProcedure>,
    filters?: InvalidateQueryFilters,
    options?: InvalidateOptions,
  ): Promise<void>;
  // ... and so on
};

export type DecoratedProcedureUtilsRecord<TRouter extends AnyRouter> =
  OmitNeverKeys<{
    [TKey in keyof TRouter['_def']['record']]: TRouter['_def']['record'][TKey] extends LegacyV9ProcedureTag
      ? never
      : TRouter['_def']['record'][TKey] extends AnyRouter
      ? DecoratedProcedureUtilsRecord<TRouter['_def']['record'][TKey]>
      : TRouter['_def']['record'][TKey] extends QueryProcedure<any>
      ? DecorateProcedure<TRouter, TRouter['_def']['record'][TKey]>
      : never;
  }>;
```

Ok wow, that's a lot, let's walk through this first. It's a recursive type that walks through all the procedures in the router and "decorates" (adds methods to) them with the React Query utilities like [`invalidateQueries`](https://tanstack.com/query/v4/docs/guides/query-invalidation). Since tRPC v10 we still support v9 procedures, we do a check to make sure they don't work on our v10 API. It's all a lot of work for TypeScript to do, **if it's not lazily evaluated**.

### Lazy evaluation

The problem here is that TypeScript is evaluating all of this code in the type system, even though it's not used immediately. TypeScript defers evaluation of properties on objects so theoretically our type above should work fine...right? Well, it's not exactly an object. There's a type wrapping the entire thing, `OmitNeverKeys`. This type is a utility that removes keys that have the value `never` from an object. We do this because we don't want those properties (v9 procedures) to show up in intellisense.

But this created a huge issue. We forced TypeScript to evaluate the values of _all_ types now to check if they are `never`. How can we fix this? Change our types to _do less_.

### Do less

Why must our v10 API adapt to v9 requirements? New tRPC projects should not suffer from the reduced TypeScript performance of our interop mode.

We had to re-arrange the core types themselves. v9 procedures are different entities and thus should not share a space with our v10 procedures. On the tRPC server side, this means we had to store the types on different fields in the router instead of one `record` field (see `DecoratedProcedureUtilsRecord` above).

We changed it so v9 routers inject their procedures into the `legacy` field when they are converted to v10 routers.

Here's an extremely simplified version of the change:

Old types:

```ts
export type V10Router<TProcedures> = {
  procedures: TProcedures;
};

export type MigrateV9Router<TV9Router extends V9Router> = V10Router<{
  [TKey in keyof TV9Router['procedures']]: TV9Router['procedures'][TKey] &
    LegacyV9ProcedureTag;
}>;
```

New types:

```ts
export type V10Router<TProcedures> = {
  procedures: TProcedures;
};

export type MigrateV9Router<TV9Router extends V9Router> = V10Router<{}> & {
  legacy: {
    procedures: TV9Router['procedures'];
  };
};
```

Now, we can remove `OmitNeverKeys` and stop forcing TypeScript to evaluate the huge `LegacyV9ProcedureTag` type. We can remove the filtering for v9 procedures entirely.

## Conclusion

Our new trace showed that the bottleneck was removed:
![trace bar showing that src/pages/index.ts took 136ms to type-check](https://user-images.githubusercontent.com/58836760/190300687-ef85589e-a997-4fa0-be0f-547f12801b2c.png)

This shows a substantial improvement! Type-checking time went from 332ms to 136ms ðŸ¤¯! This may not seem like much in the big picture but it's a huge win. Users will and have noticed how much better their editing experiences are with faster types.

Type-checking performance can be the difference between a large project/company deciding to use your project or not. For tRPC, we proved that we can push the limits of TypeScript and deliver a great DX for both small and large projects.

Did you like this post? @ me on [Twitter](https://twitter.com/s4chinraja) if you have any questions and I'd love to help!
